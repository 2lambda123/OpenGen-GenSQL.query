# inferenceql.query
![tests](https://github.com/OpenIQL/inferenceql.query/workflows/tests/badge.svg)
![linter](https://github.com/OpenIQL/inferenceql.query/workflows/linter/badge.svg)

## Usage

### Command-line interface

`inferenceql.query` provides a simple command-line application that allows the user to manually enter and evaluate InferenceQL queries. It can be launched with the following command:

``` bash
% clj -M -m inferenceql.query.main --help
  -t, --table NAME=PATH  []  table CSV name and path
  -m, --model NAME=PATH  []  model EDN name and path
  -e, --eval STRING          evaluate query in STRING
  -o, --output FORMAT        output format
  -h, --help
```

If a query is provided it will be evaluated and the result will be printed. If a query is not provided a REPL will be launched.

`PATH` may be either a local file name or a URI.

```
% clj -m inferenceql.query.main --table data=data.csv --model model=model.edn
```

```
% clj -m inferenceql.query.main --table data=https://bcomp.pro/elephantdata --model model=https://bcomp.pro/elephantmodel
```

If `-t/--table` is not provided a CSV will be read from stdin and bound to `data`.

``` bash
% curl -sL https://bcomp.pro/elephantdata | clojure -M -m inferenceql.query.main --eval "SELECT * FROM data LIMIT 1"

| elephant | rain | teacher_sick | student_happy |
|----------+------+--------------+---------------|
|      yes |  yes |           no |           yes |
```

### Clojure interface

``` clojure
(require '[inferenceql.query :as query])
(require '[inferenceql.query.db :as db])

(defn q
  [query tables models]
  (let [db (as-> (db/empty)
               %
             (reduce-kv db/with-table % tables)
             (reduce-kv db/with-model % models))]
    (query/q query db)))
```

`inferenceql.query` exposes the function `inferenceql.query/q`, which can be used to evaluate queries. It accepts three positional arguments:

1. a query to be evaluate, a string
2. a data table, a possibly empty vector of maps
3. (optional) models, a map from model names to model values

See below for usage examples.

## Language

### `SELECT`

`SELECT` behaves as it does in SQL. The table provided as the second argument to `inferenceql.query/q` is bound to `data`.

``` clojure
(q "SELECT * FROM data"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 0 :y 2}
    {:x 1 :y 1}
    {:x 2 :y 0}]
```

Individual columns can be selected.

``` clojure
(q "SELECT x FROM data"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 0}
    {:x 1}
    {:x 2}]
```

### `ORDER BY`

By default, results are returned in the order that they were provided (or generated by the model in the case of virtual data â€” see `GENERATE` below). `ORDER BY` behaves as it does in SQL. If `ORDER BY` is provided without either `ASC` or `DESC`, results are returned in ascending order.

``` clojure
(q "SELECT * FROM data ORDER BY y"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 2 :y 0}
    {:x 1 :y 1}
    {:x 0 :y 2}]
```

``` clojure
(q "SELECT * FROM data ORDER BY y ASC"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 2 :y 0}
    {:x 1 :y 1}
    {:x 0 :y 2}]
```

``` clojure
(q "SELECT * FROM data ORDER BY y DESC"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 0 :y 2}
    {:x 1 :y 1}
    {:x 2 :y 0}]
```

### `LIMIT`

`LIMIT n` behaves as it does in SQL, returning the first `n` results if there are more than `n`. Otherwise all results will be returned. See above for information about the ordering of results, including the default sort order.

``` clojure
(q "SELECT x FROM data LIMIT 2"
   {:data [{:x 0}
           {:x 1}
           {:x 2}]})
=> [{:x 0}
    {:x 1}]
```

### `WHERE`

#### `=`, `>`, `<`, `>=`, and `<=`

Five binary predicates can be used in `WHERE` clauses.

``` clojure
(q "SELECT * FROM data WHERE x = 1"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 1 :y 1}]
```

``` clojure
(q "SELECT * FROM data WHERE x > 1"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 2 :y 0}]
```

``` clojure
(q "SELECT * FROM data WHERE x < 1"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 0 :y 2}]
```

``` clojure
(q "SELECT * FROM data WHERE x >= 1"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 1 :y 1}
    {:x 2 :y 0}]
```

``` clojure
(q "SELECT * FROM data WHERE x <= 1"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 0 :y 2}
    {:x 1 :y 1}]
```

#### `AND` and `OR`

Conditions can be joined together with `AND` and `OR`.

``` clojure
(q "SELECT * FROM data WHERE x > 0 AND y > 0"
   {:data [{:x 0 :y 2}
           {:x 1 :y 1}
           {:x 2 :y 0}]})
=> [{:x 1 :y 1}]
```

`AND` has higher precedence than `OR`.

``` clojure
(q "SELECT * FROM data WHERE x = 0 AND x = 1 OR x = 1"
   {:data [{:x 1}]})
=> [{:x 1}]
```

#### `IS NULL`, `IS NOT NULL`

`IS NULL` and `IS NOT NULL` behave as they do in SQL.

``` clojure
(q "SELECT x FROM data WHERE y IS NULL"
   {:data [{:x 0 :y 2}
           {:x 1}
           {:x 2 :y 1}]})
=> [{:x 1}]
```

``` clojure
(q "SELECT x FROM data WHERE y IS NOT NULL"
   {:data [{:x 0 :y 2}
           {:x 1}
           {:x 2 :y 1}]})
=> [{:x 0}
    {:x 2}]
```

### `PROBABILITY DENSITY OF`

In addition to columns, one can also select the or probability density of a set of events occurring under an `inferenceql.inference` model. `PROBABILITY DENSITY OF` will return a number that expresses relative likelihood of the event occurring under the model. 

To make models available for querying a map with model names as keys and models as values may be passed to `inferenceql.q` via an optional third argument.

``` clojure
(require '[inferenceql.inference.gpm :as gpm])

(def model
  (gpm/Multimixture
   {:vars {:x :categorical
           :y :categorical}
    :views [[{:probability 0.75
              :parameters  {:x {"yes" 1.0 "no" 0.0}
                            :y {"yes" 1.0 "no" 0.0}}}
             {:probability 0.25
              :parameters  {:x {"yes" 0.0 "no" 1.0}
                            :y {"yes" 0.0 "no" 1.0}}}]]}))
```

If a variable appears alone, then the probability density of the variable with that name, taking on the value in the column with the same name, is returned.

``` clojure
(q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER model) AS p FROM data"
   {:data [{:x "yes" :y "yes"}
           {:x "yes" :y "no"}
           {:x "no"  :y "yes"}
           {:x "no"  :y "no"}]}
   {:model model})
=> [{:p 0.75}
    {:p 0.75}
    {:p 0.25}
    {:p 0.25}]
```

#### `CONDITIONED BY`

``` clojure
(q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER model CONDITIONED BY VAR y = y) AS p FROM data"
   {:data [{:x "yes" :y "yes"}
           {:x "yes" :y "no"}
           {:x "no"  :y "yes"}
           {:x "no"  :y "no"}]}
   {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 0.0}
    {:p 1.0}]
```

Literal events may also be provided.

``` clojure
(q "SELECT (PROBABILITY DENSITY OF VAR x = \"yes\" UNDER model CONDITIONED BY VAR y = y) AS p FROM data"
   {:data [{:x "yes" :y "yes"}
           {:x "yes" :y "no"}
           {:x "no"  :y "yes"}
           {:x "no"  :y "no"}]}
   {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 1.0}
    {:p 0.0}]
```

``` clojure
(q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER model CONDITIONED BY VAR y = \"yes\") AS p FROM data"
   {:data [{:x "yes" :y "yes"}
           {:x "yes" :y "no"}
           {:x "no"  :y "yes"}
           {:x "no"  :y "no"}]}
   {:model model})
=> [{:p 1.0}
    {:p 1.0}
    {:p 0.0}
    {:p 0.0}]
```

### `GENERATE`

One can also use generated values from a model as a data source.

``` clojure
(def always-yes-model
  (gpm/Multimixture
   {:vars {:x :categorical}
    :views [[{:probability 1.0
              :parameters {:x {"yes" 1.0}}}]]}))
```

``` clojure
(q "SELECT * FROM (GENERATE VAR x UNDER model) LIMIT 3"
   {:data [{:x "no"}]}
   {:model always-yes-model})
=> [{:x "yes"}
    {:x "yes"}
    {:x "yes"}]
```

One can also generate values that are subject to conditions.

``` clojure
(q "SELECT * FROM (GENERATE VAR x UNDER model CONDITIONED BY VAR y=\"yes\" ) LIMIT 3"
   {:data [{:x "no"}]}
   {:model model})
=> [{:x "yes"}
    {:x "yes"}
    {:x "yes"}]
```

One can also compute the probability density of an event under a model that is subject to conditions.

``` clojure
(q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER (model CONDITIONED BY VAR y=\"yes\")) AS p FROM data"
   {:data [{:x "yes" :y "yes"}
           {:x "yes" :y "no"}
           {:x "no"  :y "yes"}
           {:x "no"  :y "no"}]}
   {:model model})
=> [{:p 1.0}
    {:p 1.0}
    {:p 0.0}
    {:p 0.0}]
```

### JavaScript interface

The library can be built into a stand-alone `.js` bundle with the following command:

``` shell
clojure -M:js-build
```

After loading the JavaScript bundle a query can be issued by calling the function `inferenceql.query.js.query`:

``` javascript
inferenceql.query.js.query("SELECT *", [{x: 0}, {x: 1}, {x: 2}], {model: ...})
```
