# inferenceql.query
![tests](https://github.com/probcomp/inferenceql.query/workflows/tests/badge.svg)
![linter](https://github.com/probcomp/inferenceql.query/workflows/linter/badge.svg)

## Usage

### Command-line interface

`inferenceql.query` provides a simple command-line application that allows the user to manually enter and evaluate InferenceQL queries. It can be launched with the following command:

```bash
% clj -M -m inferenceql.query.main --help
  -d, --data DATA      data CSV path
  -m, --model MODEL    model EDN path
  -s, --schema SCHEMA  schema EDN path
  -e, --eval STRING    evaluate query in STRING
  -o, --output FORMAT  output format
  -h, --help
```

If a query is provided it will be evaluated and the result will be printed. If a query is not provided a REPL will be launched.

`DATA` may be either a local file name or a URI.

```
% clj -m inferenceql.query.main --data data.csv --model model.edn
```

```
% clj -m inferenceql.query.main --data https://bcomp.pro/elephantdata --model https://bcomp.pro/elephantmodel
```

If `DATA` is not provided the dataset will be read from stdin.

``` bash
% curl -sL https://bcomp.pro/elephantdata | clojure -M -m inferenceql.query.main --model https://bcomp.pro/elephantmodel --eval "SELECT * FROM data LIMIT 1"

| elephant | rain | student_happy | teacher_sick |
|----------+------+---------------+--------------|
|       no |   no |           yes |           no |
```

### Clojure interface

```clojure
(require '[inferenceql.query :as query])
```

`inferenceql.query` exposes the function `inferenceql.query/q`, which can be used to evaluate queries. It accepts three positional arguments:

1. a query to be evaluate, a string
2. a data table, a possibly empty vector of maps
3. (optional) models, a map from model names to model values

See below for usage examples.

## Language

### `SELECT`

`SELECT` behaves as it does in SQL. The table provided as the second argument to `inferenceql.query/q` is bound to `data`.

```clojure
(query/q "SELECT * FROM data"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}
    {:x 1 :y 1}
    {:x 2 :y 0}]
```

Individual columns can be selected.

```clojure
(query/q "SELECT x FROM data"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0}
    {:x 1}
    {:x 2}]
```

### `ORDER BY`

By default, results are returned in the order that they were provided (or generated by the model in the case of virtual data â€” see `GENERATE` below). `ORDER BY` behaves as it does in SQL. If `ORDER BY` is provided without either `ASC` or `DESC`, results are returned in ascending order.

```clojure
(query/q "SELECT * FROM data ORDER BY y"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 2 :y 0}
    {:x 1 :y 1}
    {:x 0 :y 2}]
```

```clojure
(query/q "SELECT * FROM data ORDER BY y ASC"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 2 :y 0}
    {:x 1 :y 1}
    {:x 0 :y 2}]
```

```clojure
(query/q "SELECT * FROM data ORDER BY y DESC"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}
    {:x 1 :y 1}
    {:x 2 :y 0}]
```

### `LIMIT`

`LIMIT n` behaves as it does in SQL, returning the first `n` results if there are more than `n`. Otherwise all results will be returned. See above for information about the ordering of results, including the default sort order.

```clojure
(query/q "SELECT x FROM data LIMIT 2"
         [{:x 0}
          {:x 1}
          {:x 2}])
=> [{:x 0}
    {:x 1}]
```

### `WHERE`

#### `=`, `>`, `<`, `>=`, and `<=`

Five binary predicates can be used in `WHERE` clauses.

```clojure
(query/q "SELECT * FROM data WHERE x = 1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 1 :y 1}]
```

```clojure
(query/q "SELECT * FROM data WHERE x > 1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 2 :y 0}]
```

```clojure
(query/q "SELECT * FROM data WHERE x < 1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}]
```

```clojure
(query/q "SELECT * FROM data WHERE x >= 1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 1 :y 1}
    {:x 2 :y 0}]
```

```clojure
(query/q "SELECT * FROM data WHERE x <= 1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}
    {:x 1 :y 1}]
```

#### `AND` and `OR`

Conditions can be joined together with `AND` and `OR`.

```clojure
(query/q "SELECT * FROM data WHERE x > 0 AND y > 0"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 1 :y 1}]
```

`AND` has higher precedence than `OR`.

```clojure
(query/q "SELECT * FROM data WHERE x = 0 AND x = 1 OR x = 1"
         [{:x 1}])
=> [{:x 1}]
```

#### `IS NULL`, `IS NOT NULL`

`IS NULL` and `IS NOT NULL` behave as they do in SQL.

```clojure
(query/q "SELECT x FROM data WHERE y IS NULL"
         [{:x 0 :y 2}
          {:x 1}
          {:x 2 :y 1}])
=> [{:x 1}]
```

```clojure
(query/q "SELECT x FROM data WHERE y IS NOT NULL"
         [{:x 0 :y 2}
          {:x 1}
          {:x 2 :y 1}])
=> [{:x 0}
    {:x 2}]
```

### `PROBABILITY DENSITY OF`

In addition to columns, one can also select the or probability density of a set of events occurring under an `inferenceql.inference` model. `PROBABILITY DENSITY OF` will return a number that expresses relative likelihood of the event occurring under the model. 

To make models available for querying a map with model names as keys and models as values may be passed to `inferenceql.query/q` via an optional third argument.

```clojure
(require '[inferenceql.inference.gpm :as gpm])

(def model
  (gpm/Multimixture
   {:vars {:x :categorical
           :y :categorical}
    :views [[{:probability 0.75
              :parameters  {:x {"yes" 1.0 "no" 0.0}
                            :y {"yes" 1.0 "no" 0.0}}}
             {:probability 0.25
              :parameters  {:x {"yes" 0.0 "no" 1.0}
                            :y {"yes" 0.0 "no" 1.0}}}]]}))
```

If a variable appears alone, then the probability density of the variable with that name, taking on the value in the column with the same name, is returned.

```clojure
(query/q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER model) AS p FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 0.75}
    {:p 0.75}
    {:p 0.25}
    {:p 0.25}]
```

#### `CONDITIONED BY`

```clojure
(query/q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER model CONDITIONED BY VAR y = y) AS p FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 0.0}
    {:p 1.0}]
```

Literal events may also be provided.

```clojure
(query/q "SELECT (PROBABILITY DENSITY OF VAR x = \"yes\" UNDER model CONDITIONED BY VAR y = y) AS p FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 1.0}
    {:p 0.0}]
```

```clojure
(query/q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER model CONDITIONED BY VAR y = \"yes\") AS p FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 1.0}
    {:p 0.0}
    {:p 0.0}]
```

### `GENERATE`

One can also use generated values from a model as a data source.

```clojure
(def always-yes-model
  (gpm/Multimixture
   {:vars {:x :categorical}
    :views [[{:probability 1.0
              :parameters {:x {"yes" 1.0}}}]]}))
```

```clojure
(query/q "SELECT * FROM (GENERATE VAR x UNDER model) LIMIT 3"
         [{:x "no"}]
         {:model always-yes-model})
=> [{:x "yes"}
    {:x "yes"}
    {:x "yes"}]
```

One can also generate values that are subject to conditions.

```clojure
(query/q "SELECT * FROM (GENERATE VAR x UNDER model CONDITIONED BY VAR y=\"yes\" ) LIMIT 3"
         [{:x "no"}]
         {:model model})
=> [{:x "yes"}
    {:x "yes"}
    {:x "yes"}]
```

One can also compute the probability density of an event under a model that is subject to conditions.

```clojure
(query/q "SELECT (PROBABILITY DENSITY OF VAR x = x UNDER (model CONDITIONED BY VAR y=\"yes\")) AS p FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 1.0}
    {:p 0.0}
    {:p 0.0}]
```

### JavaScript interface

The library can be built into a stand-alone `.js` bundle with the following command:

``` shell
clojure -M:js-build
```

After loading the JavaScript bundle a query can be issued by calling the function `inferenceql.query.js.query`:

``` javascript
inferenceql.query.js.query("SELECT *", [{x: 0}, {x: 1}, {x: 2}], {model: ...})
```
