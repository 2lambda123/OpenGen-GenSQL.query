# inferenceql.query
![tests](https://github.com/probcomp/inferenceql.query/workflows/tests/badge.svg)
![linter](https://github.com/probcomp/inferenceql.query/workflows/linter/badge.svg)

## Usage

### Command-line interface

`inferenceql.query` provides a simple command-line application that allows the user to manually enter and evaluate InferenceQL queries. It can be launched with the following command:

```bash
% clj -M -m inferenceql.query.main --help
  -d, --data DATA    data CSV path
  -m, --model MODEL  model EDN path
  -e, --eval QUERY   QUERY to evaluate
  -h, --help
```

If a query is provided it will be evaluated and the result will be printed. If a query is not provided a REPL will be launched.

`DATA` may be either a local file name or a URI.

```
% clj -m inferenceql.query.main --data data.csv --model model.edn
```

```
% clj -m inferenceql.query.main --data https://bcomp.pro/elephantdata --model https://bcomp.pro/elephantmodel
```

If `DATA` is not provided the dataset will be read from stdin.

``` bash
% curl -sL https://bcomp.pro/elephantdata | clojure -M -m inferenceql.query.main --model https://bcomp.pro/elephantmodel --eval "SELECT * FROM data LIMIT 1"

| elephant | rain | student_happy | teacher_sick |
|----------+------+---------------+--------------|
|       no |   no |           yes |           no |
```

### Clojure interface

```clojure
(require '[inferenceql.query :as query])
```

`inferenceql.query` exposes the function `inferenceql.query/q`, which can be used to evaluate queries. It accepts three positional arguments:

1. a query to be evaluate, a string
2. a data table, a possibly empty vector of maps
3. (optional) models, a map from model names to model values

See below for usage examples.

## Language

### `SELECT`

`SELECT` behaves as it does in SQL. The table provided as the second argument to `inferenceql.query/q` is bound to `data`.

```clojure
(query/q "SELECT * FROM data"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}
    {:x 1 :y 1}
    {:x 2 :y 0}]
```

Individual columns can be selected.

```clojure
(query/q "SELECT x FROM data"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0}
    {:x 1}
    {:x 2}]
```

The `FROM` clause can be omitted, in which case the data source is assumed to be `data`.

```clojure
(query/q "SELECT x"
         [{:x 0}
          {:x 1}
          {:x 2}])
=> [{:x 0}
    {:x 1}
    {:x 2}]
```

The row index can be selected.

```clojure
(query/q "SELECT rowid, x FROM data"
         [{:x 0}
          {:x 1}
          {:x 2}])
=> [{:rowid 1 :x 0}
    {:rowid 2 :x 1}
    {:rowid 3 :x 2}]
```

### `ORDER BY`

By default, results are returned in the order that they were provided (or generated by the model in the case of virtual data â€” see `GENERATE` below). `ORDER BY` behaves as it does in SQL. If `ORDER BY` is provided without either `ASC` or `DESC`, results are returned in ascending order.

```clojure
(query/q "SELECT * FROM data ORDER BY y"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 2 :y 0}
    {:x 1 :y 1}
    {:x 0 :y 2}]
```

```clojure
(query/q "SELECT * FROM data ORDER BY y ASC"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 2 :y 0}
    {:x 1 :y 1}
    {:x 0 :y 2}]
```

```clojure
(query/q "SELECT * FROM data ORDER BY y DESC"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}
    {:x 1 :y 1}
    {:x 2 :y 0}]
```

### `LIMIT`

`LIMIT n` behaves as it does in SQL, returning the first `n` results if there are more than `n`. Otherwise all results will be returned. See above for information about the ordering of results, including the default sort order.

```clojure
(query/q "SELECT x FROM data LIMIT 2"
         [{:x 0}
          {:x 1}
          {:x 2}])
=> [{:x 0}
    {:x 1}]
```

### `WHERE`

#### `=`, `>`, `<`, `>=`, and `<=`

Five binary predicates can be used in `WHERE` clauses.

```clojure
(query/q "SELECT * FROM data WHERE x=1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 1 :y 1}]
```

```clojure
(query/q "SELECT * FROM data WHERE x>1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 2 :y 0}]
```

```clojure
(query/q "SELECT * FROM data WHERE x<1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}]
```

```clojure
(query/q "SELECT * FROM data WHERE x>=1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 1 :y 1}
    {:x 2 :y 0}]
```

```clojure
(query/q "SELECT * FROM data WHERE x<=1"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 0 :y 2}
    {:x 1 :y 1}]
```

#### `AND` and `OR`

Conditions can be joined together with `AND` and `OR`.

```clojure
(query/q "SELECT * FROM data WHERE x>0 AND y>0"
         [{:x 0 :y 2}
          {:x 1 :y 1}
          {:x 2 :y 0}])
=> [{:x 1 :y 1}]
```

`AND` has higher precedence than `OR`.

```clojure
(query/q "SELECT * FROM data WHERE x=0 AND x=1 OR x=1"
         [{:x 1}])
=> [{:x 1}]
```

#### `IS NULL`, `IS NOT NULL`

`IS NULL` and `IS NOT NULL` behave as they do in SQL.

```clojure
(query/q "SELECT x FROM data WHERE y IS NULL"
         [{:x 0 :y 2}
          {:x 1}
          {:x 2 :y 1}])
=> [{:x 1}]
```

```clojure
(query/q "SELECT x FROM data WHERE y IS NOT NULL"
         [{:x 0 :y 2}
          {:x 1}
          {:x 2 :y 1}])
=> [{:x 0}
    {:x 2}]
```

### `PROBABILITY OF` and `PROBABILITY DENSITY OF`

In addition to columns, one can also select the probability of, or probability density of, a set of events occurring under an `inferenceql.inference` model. `PROBABILITY OF` will return the (normalized) likelihood of the events occurring under the model as a number between `0` and `1`. `PROBABILITY DENSITY OF` will return a number that expresses relative likelihood of the event occurring under the model. The behavior of `PROBABILITY OF` is only defined when it is used with categorical variables (variables that can take on one of a limited number of possible values).

To make models available for querying a map with model names as keys and models as values may be passed to `inferenceql.query/q` via an optional third argument.

```clojure
(require '[inferenceql.inference.gpm :as gpm])

(def model
  (gpm/Multimixture
   {:vars {:x :categorical
           :y :categorical}
    :views [[{:probability 0.75
              :parameters  {:x {"yes" 1.0 "no" 0.0}
                            :y {"yes" 1.0 "no" 0.0}}}
             {:probability 0.25
              :parameters  {:x {"yes" 0.0 "no" 1.0}
                            :y {"yes" 0.0 "no" 1.0}}}]]}))
```

If a variable appears alone, then the probability of the variable with that name, taking on the value in the column with the same name, is returned.

```clojure
(query/q "SELECT (PROBABILITY OF x UNDER model AS p) FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 0.75}
    {:p 0.75}
    {:p 0.25}
    {:p 0.25}]
```

#### `CONDITIONED BY`

```clojure
(query/q "SELECT (PROBABILITY OF x UNDER model CONDITIONED BY y AS p) FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 0.0}
    {:p 1.0}]
```

Literal events may also be provided.

```clojure
(query/q "SELECT (PROBABILITY OF x=\"yes\" UNDER model CONDITIONED BY y AS p) FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 1.0}
    {:p 0.0}]
```

```clojure
(query/q "SELECT (PROBABILITY OF x UNDER model CONDITIONED BY y=\"yes\" AS p) FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 1.0}
    {:p 0.0}
    {:p 0.0}]
```

Though their semantics differ, the only difference between the _syntax_ of `PROBABILITY DENSITY OF` and the syntax of `PROBABILITY OF` is the addition of the keyword `DENSITY`.

```clojure
(query/q "SELECT (PROBABILITY DENSITY OF x UNDER model CONDITIONED BY y AS p) FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 0.0}
    {:p 0.0}
    {:p 1.0}]
```

### `GENERATE`

One can also use generated values from a model as a data source.

```clojure
(def always-yes-model
  (gpm/Multimixture
   {:vars {:x :categorical}
    :views [[{:probability 1.0
              :parameters {:x {"yes" 1.0}}}]]}))
```

```clojure
(query/q "SELECT * FROM (GENERATE x UNDER model) LIMIT 3"
         [{:x "no"}]
         {:model always-yes-model})
=> [{:x "yes"}
    {:x "yes"}
    {:x "yes"}]
```

One can also generate values that are subject to conditions.

```clojure
(query/q "SELECT * FROM (GENERATE x UNDER model CONDITIONED BY y=\"yes\" ) LIMIT 3"
         [{:x "no"}]
         {:model model})
=> [{:x "yes"}
    {:x "yes"}
    {:x "yes"}]
```

One can also compute the probability of an event under a model that is subject to conditions.

```clojure
(query/q "SELECT (PROBABILITY OF x UNDER (GENERATE x UNDER model CONDITIONED BY y=\"yes\" ) AS p) FROM data"
         [{:x "yes" :y "yes"}
          {:x "yes" :y "no"}
          {:x "no"  :y "yes"}
          {:x "no"  :y "no"}]
         {:model model})
=> [{:p 1.0}
    {:p 1.0}
    {:p 0.0}
    {:p 0.0}]
```
